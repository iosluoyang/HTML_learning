<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue13_prop</title>

    <script src="https://cdn.jsdelivr.net/npm/vue"></script>

</head>
<body>

<!--

    静态的和动态的 Prop

        像这样，你已经知道了可以像这样给 prop 传入一个静态的值：
        <blog-post title="My journey with Vue"></blog-post>

        你也知道 prop 可以通过 v-bind 动态赋值，例如：
        <blog-post v-bind:title="post.title"></blog-post>

        在上述两个示例中，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 prop。

        传入一个数字

        即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue
        这是一个 JavaScript 表达式而不是一个字符串
        <blog-post v-bind:likes="42"></blog-post>
        用一个变量进行动态赋值
        <blog-post v-bind:likes="post.likes"></blog-post>


        传入一个布尔值

        包含该 prop 没有值的情况在内，都意味着 `true`。
        <blog-post favorited></blog-post>
        即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue
        这是一个 JavaScript 表达式而不是一个字符串
        <base-input v-bind:favorited="false">
        用一个变量进行动态赋值。
        <base-input v-bind:favorited="post.currentUserFavorited">

        传入一个数组

        即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue
        这是一个 JavaScript 表达式而不是一个字符串
        <blog-post v-bind:comment-ids="[234, 266, 273]"></blog-post>
        用一个变量进行动态赋值。
        <blog-post v-bind:comment-ids="post.commentIds"></blog-post>

        传入一个对象

        即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue
        这是一个 JavaScript 表达式而不是一个字符串。
        <blog-post v-bind:comments="{ id: 1, title: 'My Journey with Vue' }"></blog-post>
        用一个变量进行动态赋值。
        <blog-post v-bind:post="post"></blog-post>


        传入一个对象的所有属性

        如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post：

        post: {
        id: 1,
        title: 'My Journey with Vue'
        }
        下面的模板：

        <blog-post v-bind="post"></blog-post>
        等价于：

        <blog-post
                v-bind:id="post.id"
                v-bind:title="post.title"
        ></blog-post>


-->
<!--单向数据流-->
<!--
    所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：
    父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。

    额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。



    这里有两种常见的试图改变一个 prop 的情形：

    这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：

    props: ['initialCounter'],
    data: function () {
      return {
        counter: this.initialCounter
      }
    }
    这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：

    props: ['size'],
    computed: {
      normalizedSize: function () {
        return this.size.trim().toLowerCase()
      }
    }


    注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。

-->

<!--非prop特性-->
<!--
    一个非 prop 特性是指传向一个组件，但是该组件并没有相应 prop 定义的特性。

    因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。
    这也是为什么组件可以接受任意的特性，而这些特性会被添加到这个组件的根元素上。


    除了类似于type='text'这样的特性父组件会覆盖子组件之外  其他的类似于style以及class都是叠加的原理
    如果不希望父组件的某些特性传递给子组件的话,只需要在声明父组件的时候声明一下inheritAttrs: false 即可阻止其中的子组件继承父组件的某些特性
-->


</body>
</html>